<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT-6.824-Lab1(MapReduce)</title>
    <link href="/2024/12/25/MIT-6-824-Lab1-MapReduce/"/>
    <url>/2024/12/25/MIT-6-824-Lab1-MapReduce/</url>
    
    <content type="html"><![CDATA[<h1 id="MIT-6-824-Lab1-MapReduce"><a href="#MIT-6-824-Lab1-MapReduce" class="headerlink" title="MIT-6.824-Lab1(MapReduce)"></a>MIT-6.824-Lab1(MapReduce)</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><h3 id="任务：实现分布式MapReduce"><a href="#任务：实现分布式MapReduce" class="headerlink" title="任务：实现分布式MapReduce"></a>任务：实现分布式MapReduce</h3><p>你的任务是实现一个分布式MapReduce，包括两个程序：<strong>协调者（coordinator）</strong>和<strong>工作者（worker）</strong>。系统中只有一个协调者进程，以及一个或多个并行执行的工作者进程。在真实系统中，工作者会运行在多台不同的机器上，但在本实验中，你将在单台机器上运行它们。工作者通过RPC与协调者通信。每个工作者进程将循环执行以下操作：</p><ol><li>向协调者请求任务。</li><li>从一个或多个文件中读取任务的输入。</li><li>执行任务。</li><li>将一个或多个文件写入任务的输出。</li><li>再次向协调者请求新任务。</li></ol><p>协调者应检测工作者是否在合理的时间内（本实验中使用10秒）完成任务，如果没有完成，则将相同的任务分配给其他工作者。</p><h3 id="任务细节：实现MapReduce的Map和Reduce阶段"><a href="#任务细节：实现MapReduce的Map和Reduce阶段" class="headerlink" title="任务细节：实现MapReduce的Map和Reduce阶段"></a>任务细节：实现MapReduce的Map和Reduce阶段</h3><h4 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h4><ul><li><strong>任务划分</strong>：Map阶段应将中间键划分为 <code>nReduce</code> 个桶，其中 <code>nReduce</code> 是Reduce任务的数量——这是 <code>main/mrcoordinator.go</code> 传递给 <code>MakeCoordinator()</code> 的参数。</li><li><strong>中间文件</strong>：每个Mapper应创建 <code>nReduce</code> 个中间文件，供Reduce任务使用。</li></ul><h4 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h4><ul><li><strong>输出文件</strong>：第X个Reduce任务的输出应放在文件 <code>mr-out-X</code> 中。</li><li><strong>输出格式</strong>：<code>mr-out-X</code> 文件应包含每行Reduce函数输出。每行应使用Go的 <code>&quot;%v %v&quot;</code> 格式生成，调用时传入键和值。可以参考 <code>main/mrsequential.go</code> 中注释为 “this is the correct format” 的行。如果实现偏离此格式太多，测试脚本将失败。</li></ul><h4 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h4><ul><li>你可以修改 <code>mr/worker.go</code>、<code>mr/coordinator.go</code> 和 <code>mr/rpc.go</code>。</li><li>你可以临时修改其他文件进行测试，但确保你的代码与原始版本兼容；我们将使用原始版本进行测试。</li></ul><h4 id="中间文件存储"><a href="#中间文件存储" class="headerlink" title="中间文件存储"></a>中间文件存储</h4><ul><li>工作者应将中间Map输出放在当前目录的文件中，以便稍后作为Reduce任务的输入读取。</li></ul><h4 id="任务完成"><a href="#任务完成" class="headerlink" title="任务完成"></a>任务完成</h4><ul><li><code>main/mrcoordinator.go</code> 期望 <code>mr/coordinator.go</code> 实现一个 <code>Done()</code> 方法，当MapReduce作业完全完成时返回 <code>true</code>；此时，<code>mrcoordinator.go</code> 将退出。</li><li>当作业完全完成时，工作者进程应退出。一个简单的实现方法是使用 <code>call()</code> 的返回值：如果工作者无法联系协调者，它可以假设协调者已退出，因为作业已完成，因此工作者也可以终止。根据你的设计，你可能还会发现有一个“请退出”的伪任务对协调者很有帮助。</li></ul><h3 id="开发与调试指南"><a href="#开发与调试指南" class="headerlink" title="开发与调试指南"></a>开发与调试指南</h3><h4 id="1-开始开发"><a href="#1-开始开发" class="headerlink" title="1. 开始开发"></a>1. <strong>开始开发</strong></h4><ul><li>修改 <code>mr/worker.go</code> 中的 <code>Worker()</code> 函数，使其向协调者发送RPC请求以获取任务。</li><li>修改协调者，使其响应一个尚未启动的Map任务的文件名。</li><li>修改工作者，使其读取该文件并调用应用程序的Map函数（如 <code>mrsequential.go</code> 中所示）。</li></ul><h4 id="2-加载Map和Reduce函数"><a href="#2-加载Map和Reduce函数" class="headerlink" title="2. 加载Map和Reduce函数"></a>2. <strong>加载Map和Reduce函数</strong></h4><ul><li>应用程序的Map和Reduce函数在运行时通过Go的插件包加载，文件名以 <code>.so</code> 结尾。</li><li>如果你修改了 <code>mr/</code> 目录中的任何内容，可能需要重新构建你使用的MapReduce插件，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -buildmode=plugin ../mrapps/wc.go<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-文件系统共享"><a href="#3-文件系统共享" class="headerlink" title="3. 文件系统共享"></a>3. <strong>文件系统共享</strong></h4><ul><li>本实验依赖于工作者共享文件系统。当所有工作者运行在同一台机器上时，这很简单，但如果工作者运行在不同机器上，则需要像GFS这样的全局文件系统。</li></ul><h4 id="4-中间文件命名"><a href="#4-中间文件命名" class="headerlink" title="4. 中间文件命名"></a>4. <strong>中间文件命名</strong></h4><ul><li>中间文件的合理命名约定是 <code>mr-X-Y</code>，其中 <code>X</code> 是Map任务编号，<code>Y</code> 是Reduce任务编号。</li></ul><h4 id="5-存储中间键值对"><a href="#5-存储中间键值对" class="headerlink" title="5. 存储中间键值对"></a>5. <strong>存储中间键值对</strong></h4><ul><li>工作者的Map任务代码需要一种方式将中间键值对存储在文件中，以便在Reduce任务中正确读取。可以使用Go的 <code>encoding/json</code> 包：<ul><li><strong>写入JSON格式</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">enc := json.NewEncoder(file)<br><span class="hljs-keyword">for</span> _, kv := ... &#123;<br>  err := enc.Encode(&amp;kv)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>读取JSON格式</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">dec := json.NewDecoder(file)<br><span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-keyword">var</span> kv KeyValue<br>  <span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">break</span><br>  &#125;<br>  kva = <span class="hljs-built_in">append</span>(kva, kv)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-选择Reduce任务"><a href="#6-选择Reduce任务" class="headerlink" title="6. 选择Reduce任务"></a>6. <strong>选择Reduce任务</strong></h4><ul><li>工作者的Map部分可以使用 <code>ihash(key)</code> 函数（在 <code>worker.go</code> 中）为给定键选择Reduce任务。</li></ul><h4 id="7-代码复用"><a href="#7-代码复用" class="headerlink" title="7. 代码复用"></a>7. <strong>代码复用</strong></h4><ul><li>可以从 <code>mrsequential.go</code> 中借鉴一些代码，用于读取Map输入文件、在Map和Reduce之间排序中间键值对，以及将Reduce输出存储在文件中。</li></ul><h4 id="8-并发协调者"><a href="#8-并发协调者" class="headerlink" title="8. 并发协调者"></a>8. <strong>并发协调者</strong></h4><ul><li>协调者作为RPC服务器是并发的；不要忘记锁定共享数据。</li></ul><h4 id="9-使用Go的竞争检测器"><a href="#9-使用Go的竞争检测器" class="headerlink" title="9. 使用Go的竞争检测器"></a>9. <strong>使用Go的竞争检测器</strong></h4><ul><li>使用 <code>go run -race</code> 运行代码。<code>test-mr.sh</code> 开头有注释，告诉你如何使用 <code>-race</code>。虽然我们在评分时不会使用竞争检测器，但如果你的代码存在竞争，即使没有竞争检测器，测试时也可能失败。</li></ul><h4 id="10-工作者等待"><a href="#10-工作者等待" class="headerlink" title="10. 工作者等待"></a>10. <strong>工作者等待</strong></h4><ul><li>工作者有时需要等待，例如Reduce任务直到最后一个Map任务完成后才能开始。一种方法是工作者定期向协调者请求任务，并在每次请求之间使用 <code>time.Sleep()</code> 休眠。另一种方法是协调者的相关RPC处理程序使用 <code>time.Sleep()</code> 或 <code>sync.Cond</code> 进行等待。Go为每个RPC的处理程序运行单独的线程，因此一个处理程序的等待不会阻止协调者处理其他RPC。</li></ul><h4 id="11-处理工作者故障"><a href="#11-处理工作者故障" class="headerlink" title="11. 处理工作者故障"></a>11. <strong>处理工作者故障</strong></h4><ul><li>协调者无法可靠地区分崩溃的工作者、因某种原因停滞的工作者以及执行过慢的工作者。最好的方法是协调者等待一段时间，然后放弃并将任务重新分配给其他工作者。在本实验中，协调者应等待10秒，之后假设工作者已崩溃。</li></ul><h4 id="12-备份任务"><a href="#12-备份任务" class="headerlink" title="12. 备份任务"></a>12. <strong>备份任务</strong></h4><ul><li>如果你选择实现备份任务（第3.6节），请注意我们测试你的代码在没有工作者崩溃的情况下不会调度多余的任务。备份任务应仅在相对较长的时间（例如10秒）后调度。</li></ul><h4 id="13-测试崩溃恢复"><a href="#13-测试崩溃恢复" class="headerlink" title="13. 测试崩溃恢复"></a>13. <strong>测试崩溃恢复</strong></h4><ul><li>可以使用 <code>mrapps/crash.go</code> 应用程序插件测试崩溃恢复。它会在Map和Reduce函数中随机退出。</li></ul><h4 id="14-确保文件完整性"><a href="#14-确保文件完整性" class="headerlink" title="14. 确保文件完整性"></a>14. <strong>确保文件完整性</strong></h4><ul><li>为了确保在崩溃情况下没有人观察到部分写入的文件，MapReduce论文提到使用临时文件并在完全写入后原子重命名的技巧。可以使用 <code>ioutil.TempFile</code>（或Go 1.17及更高版本中的 <code>os.CreateTemp</code>）创建临时文件，并使用 <code>os.Rename</code> 原子重命名。</li></ul><h4 id="15-调试输出文件"><a href="#15-调试输出文件" class="headerlink" title="15. 调试输出文件"></a>15. <strong>调试输出文件</strong></h4><ul><li><code>test-mr.sh</code> 在子目录 <code>mr-tmp</code> 中运行所有进程，因此如果出现问题并希望查看中间或输出文件，请查看该目录。可以临时修改 <code>test-mr.sh</code> 以在失败测试后退出，以便脚本不会继续测试（并覆盖输出文件）。</li></ul><h4 id="16-多次运行测试"><a href="#16-多次运行测试" class="headerlink" title="16. 多次运行测试"></a>16. <strong>多次运行测试</strong></h4><ul><li><code>test-mr-many.sh</code> 连续多次运行 <code>test-mr.sh</code>，这有助于发现低概率错误。它接受一个参数，表示运行测试的次数。不要并行运行多个 <code>test-mr.sh</code> 实例，因为协调者会重用相同的套接字，导致冲突。</li></ul><h4 id="17-Go-RPC注意事项"><a href="#17-Go-RPC注意事项" class="headerlink" title="17. Go RPC注意事项"></a>17. <strong>Go RPC注意事项</strong></h4><ul><li>Go RPC仅发送名称以大写字母开头的结构字段。子结构也必须具有大写的字段名称。</li><li>调用RPC <code>call()</code> 函数时，回复结构应包含所有默认值。RPC调用应如下所示：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">reply := SomeType&#123;&#125;<br>call(..., &amp;reply)<br></code></pre></td></tr></table></figure>不要在调用前设置 <code>reply</code> 的任何字段。如果传递具有非默认字段的回复结构，RPC系统可能会静默返回错误值。</li></ul><h2 id="Lab1-实现"><a href="#Lab1-实现" class="headerlink" title="Lab1-实现"></a>Lab1-实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>根据实验指南中的提示，可以先从实现coordinator给worker分配任务开始。Worker开启后不断像coordinator申请任务，任务类型分为Map、Reduce和Done三种。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>Map    TaskType = <span class="hljs-string">&quot;map&quot;</span><br>Reduce TaskType = <span class="hljs-string">&quot;reduce&quot;</span><br>Done   TaskType = <span class="hljs-string">&quot;done&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>coordinator也在对应的三种阶段中转换，在每种对应阶段中给worker分配对应类型的任务。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Phase <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>MapPhase    Phase = <span class="hljs-string">&quot;map&quot;</span><br>ReducePhase Phase = <span class="hljs-string">&quot;reduce&quot;</span><br>finish      Phase = <span class="hljs-string">&quot;finish&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>所有任务被统一定义为Task结构，根据不同的TaskType区分任务类型。Status标明当前任务的执行状态。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Status <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>Idle    Status = <span class="hljs-string">&quot;idle&quot;</span><br>Running Status = <span class="hljs-string">&quot;running&quot;</span><br>Finish  Status = <span class="hljs-string">&quot;finish&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>File      <span class="hljs-type">string</span><br>Type      TaskType<br>WorkerId  <span class="hljs-type">string</span><br>StartTime time.Time<br>Status    Status<br>TaskId    <span class="hljs-type">int</span><br>NReduce   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外还定义了RPC相关的请求和相应结构，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> TaskRequest <span class="hljs-keyword">struct</span> &#123;<br>WorkerId <span class="hljs-type">string</span><br>Type     TaskType<br>&#125;<br><br><span class="hljs-keyword">type</span> TaskResponse <span class="hljs-keyword">struct</span> &#123;<br>Task   *Task<br>IsDone <span class="hljs-type">bool</span><br>Type   TaskType<br>&#125;<br><br><span class="hljs-keyword">type</span> MapTaskDoneRequest <span class="hljs-keyword">struct</span> &#123;<br>WorkerId <span class="hljs-type">string</span><br>Files    []<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MapTaskDoneResponse <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> ReduceTaskDoneRequest <span class="hljs-keyword">struct</span> &#123;<br>WorkerId <span class="hljs-type">string</span><br>Files    <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ReduceTaskDoneResponse <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Coordinator实现"><a href="#Coordinator实现" class="headerlink" title="Coordinator实现"></a>Coordinator实现</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your definitions here.</span><br>tasks <span class="hljs-keyword">map</span>[TaskType][]*Task <span class="hljs-comment">// 在一个map中存放不同类型的任务。</span><br><br>nMap    <span class="hljs-type">int</span><br>nReduce <span class="hljs-type">int</span><br><br>phase Phase<br>mu    sync.Mutex<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><h5 id="Map-Tasks"><a href="#Map-Tasks" class="headerlink" title="Map Tasks"></a>Map Tasks</h5><p>Map任务可直接在coordinator的初始化函数中创建，注意需要一个StartTime来确定是否超时。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;<br>c := Coordinator&#123;&#125;<br><br><span class="hljs-comment">// Your code here.</span><br>c.nMap = <span class="hljs-built_in">len</span>(files)<br>c.nReduce = nReduce<br>c.phase = MapPhase<br>c.tasks = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[TaskType][]*Task)<br><br><span class="hljs-keyword">for</span> i, file := <span class="hljs-keyword">range</span> files &#123;<br>task := Task&#123;<br>Type:      Map,<br>TaskId:    i,<br>Status:    Idle,<br>StartTime: time.Time&#123;&#125;,<br>NReduce:   nReduce,<br>File:      file,<br>&#125;<br>c.tasks[Map] = <span class="hljs-built_in">append</span>(c.tasks[Map], &amp;task)<br>&#125;<br>c.server()<br><span class="hljs-keyword">return</span> &amp;c<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Reduce-Tasks"><a href="#Reduce-Tasks" class="headerlink" title="Reduce Tasks"></a>Reduce Tasks</h5><p>Reduce任务在所有Map任务处理完毕（状态为Finish）后创建，注意这里File字段的名字使用正则表达式，在后续处理Reduce任务时根据该表达式Retrieve对应的文件。这样可以保证不同的work处理的中间文件可以被同一个reduce任务处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> generateReduceTasks() &#123;<br><span class="hljs-comment">// c.mu.Lock()</span><br><span class="hljs-comment">// defer c.mu.Unlock()</span><br>fmt.Println(<span class="hljs-string">&quot;Generate reduce tasks&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; c.nReduce; i++ &#123;<br>task := Task&#123;<br>Type:      Reduce,<br>TaskId:    i,<br>Status:    Idle,<br>StartTime: time.Time&#123;&#125;,<br>NReduce:   c.nReduce,<br>File:      fmt.Sprintf(<span class="hljs-string">&quot;%vmr-*-%v&quot;</span>, mapfilepath, i),<br>&#125;<br>c.tasks[Reduce] = <span class="hljs-built_in">append</span>(c.tasks[Reduce], &amp;task)<br><span class="hljs-comment">//fmt.Println(&quot;Generate reduce task &quot;, i, &quot; \n&quot;)</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分配任务"><a href="#分配任务" class="headerlink" title="分配任务"></a>分配任务</h4><p>coordinator默认在map阶段，GetTask根据当前所处阶段给worker分配不同类型的任务。注意每次分配Map任务之后都会检查所有Map任务是否全部完成，来转义coordinator的状态。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> GetTask(req *TaskRequest, resp *TaskResponse) <span class="hljs-type">error</span> &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br><span class="hljs-keyword">switch</span> c.phase &#123;<br><span class="hljs-keyword">case</span> MapPhase:<br>resp.Task = findAvailableTask(c.tasks[Map], req.WorkerId)<br>resp.Type = Map<br><span class="hljs-keyword">if</span> c.judgeMapDone() &#123;<br>fmt.Print(<span class="hljs-string">&quot;Map tasks done\n&quot;</span>)<br>c.phase = ReducePhase<br>c.generateReduceTasks()<br>&#125;<br><span class="hljs-keyword">case</span> ReducePhase:<br>fmt.Println(<span class="hljs-string">&quot;Assign reduce tasks&quot;</span>)<br>resp.Task = findAvailableTask(c.tasks[Reduce], req.WorkerId)<br>resp.Type = Reduce<br><span class="hljs-keyword">if</span> c.judgeReduceDone() &#123;<br>fmt.Print(<span class="hljs-string">&quot;Reduce tasks done\n&quot;</span>)<br>c.phase = finish<br>&#125;<br><span class="hljs-keyword">case</span> finish:<br>task := Task&#123;Type: Done&#125;<br>resp.Task = &amp;task<br>resp.IsDone = <span class="hljs-literal">true</span><br>c.Done()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAvailableTask</span><span class="hljs-params">(tasks []*Task, workerID <span class="hljs-type">string</span>)</span></span> *Task &#123;<br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> tasks &#123;<br><span class="hljs-keyword">if</span> t.Status == Idle || (t.Status == Running &amp;&amp; time.Now().Sub(t.StartTime) &gt; <span class="hljs-number">10</span>*time.Second) &#123;<br>t.StartTime = time.Now()<br>t.Status = Running<br>t.WorkerId = workerID<br><span class="hljs-keyword">return</span> t<br>&#125;<br>&#125;<br><span class="hljs-comment">// fmt.Println(&quot;No task available, wait for 1 second&quot;)</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改任务状态"><a href="#修改任务状态" class="headerlink" title="修改任务状态"></a>修改任务状态</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> MapTasksDone(req *MapTaskDoneRequest, resp *MapTaskDoneResponse) <span class="hljs-type">error</span> &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> c.tasks[Map] &#123;<br><span class="hljs-keyword">if</span> t.WorkerId == req.WorkerId &amp;&amp; t.Status == Running &#123;<br>t.Status = Finish<br>&#125;<br>&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;Map task done by worker %v\n&quot;, req.WorkerId)</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> ReduceTasksDone(req *ReduceTaskDoneRequest, resp *ReduceTaskDoneResponse) <span class="hljs-type">error</span> &#123;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> c.tasks[Reduce] &#123;<br><span class="hljs-keyword">if</span> t.WorkerId == req.WorkerId &#123;<br>t.Status = Finish<br>&#125;<br>&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;Reduce task done by worker %v\n&quot;, req.WorkerId)</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> judgeMapDone() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> c.tasks[Map] &#123;<br><span class="hljs-keyword">if</span> t.Status != Finish &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> judgeReduceDone() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> c.tasks[Reduce] &#123;<br><span class="hljs-keyword">if</span> t.Status != Finish &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Worker实现"><a href="#Worker实现" class="headerlink" title="Worker实现"></a>Worker实现</h3><p>Worker的主函数循环调用GetTasks的RPC Call。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue,<br>reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<br><br><span class="hljs-comment">// Your worker implementation here.</span><br><br><span class="hljs-comment">// uncomment to send the Example RPC to the coordinator.</span><br><span class="hljs-comment">// CallExample()</span><br><br>workerId := getWorkerId()<br><br><span class="hljs-keyword">for</span> &#123;<br>req := TaskRequest&#123;<br>WorkerId: workerId,<br>Type:     <span class="hljs-string">&quot;map&quot;</span>,<br>&#125;<br><br>resp := TaskResponse&#123;&#125;<br><br>ok := call(<span class="hljs-string">&quot;Coordinator.GetTask&quot;</span>, &amp;req, &amp;resp)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Task: %+v\n&quot;</span>, resp.Task)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;No task available, wait for 1 second&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> resp.Task != <span class="hljs-literal">nil</span> &amp;&amp; resp.Type == Map &#123;<br>handleMapTask(mapf, resp.Task)<br>&#125;<br><br><span class="hljs-keyword">if</span> resp.Task != <span class="hljs-literal">nil</span> &amp;&amp; resp.Task.Type == Reduce &#123;<br>handleReduceTask(reducef, resp.Task)<br>&#125;<br><br><span class="hljs-keyword">if</span> resp.Task != <span class="hljs-literal">nil</span> &amp;&amp; resp.Task.Type == Done &#123;<br>fmt.Println(<span class="hljs-string">&quot;All tasks are done&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理Map任务"><a href="#处理Map任务" class="headerlink" title="处理Map任务"></a>处理Map任务</h4><p>处理逻辑与实验说明给出的本地版本的MR类似，唯一不同的是我们要把key分类放在不同的Buckets中。实现方式是用key去做一个hash，保证相同的key在同一个bucket中即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleMapTask</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue, task *Task) &#123;<br><span class="hljs-comment">// read each input file</span><br>intermediate := <span class="hljs-built_in">make</span>([]KeyValue, <span class="hljs-number">0</span>)<br><span class="hljs-comment">//fmt.Println(&quot;Start map task&quot;)</span><br>file, err := os.Open(task.File)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, task.File)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//fmt.Printf(&quot;MAP: Read file %v\n&quot;, task.File)</span><br>&#125;<br><br>content, err := ioutil.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, task.File)<br>&#125;<br>file.Close()<br>kva := mapf(task.File, <span class="hljs-type">string</span>(content))<br>intermediate = <span class="hljs-built_in">append</span>(intermediate, kva...)<br><br><span class="hljs-comment">// write intermidiate to file</span><br>cutRes := <span class="hljs-built_in">make</span>([][]KeyValue, task.NReduce)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> cutRes &#123;<br>cutRes[i] = <span class="hljs-built_in">make</span>([]KeyValue, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, kv := <span class="hljs-keyword">range</span> intermediate &#123;<br>index := ihash(kv.Key) % task.NReduce<br>cutRes[index] = <span class="hljs-built_in">append</span>(cutRes[index], kv)<br>&#125;<br><br>files := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> cutRes &#123;<br><span class="hljs-comment">// 打开或创建目标文件，使用 O_CREATE|O_WRONLY|O_APPEND 标志</span><br>targetName := fmt.Sprintf(<span class="hljs-string">&quot;mr-%v-%v&quot;</span>, getWorkerId(), i)<br>targetPath := filepath.Join(mapfilepath, targetName)<br>targetFile, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="hljs-number">0644</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot open or create file %v: %v&quot;</span>, targetPath, err)<br>&#125;<br><span class="hljs-keyword">defer</span> targetFile.Close()<br><br>enc := json.NewEncoder(targetFile)<br><span class="hljs-keyword">for</span> _, kv := <span class="hljs-keyword">range</span> cutRes[i] &#123;<br>err := enc.Encode(&amp;kv)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot encode kv: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//fmt.Printf(&quot;MAP: Write file %v\n&quot;, targetName)</span><br>files = <span class="hljs-built_in">append</span>(files, targetPath)<br>&#125;<br><br><span class="hljs-comment">// send map task done</span><br>mapTasksDone(files)<br><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理Reduce任务"><a href="#处理Reduce任务" class="headerlink" title="处理Reduce任务"></a>处理Reduce任务</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleReduceTask</span><span class="hljs-params">(reducef <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>, task *Task) &#123;<br>intermediate := <span class="hljs-built_in">make</span>([]KeyValue, <span class="hljs-number">0</span>)<br>files, err := filepath.Glob(task.File)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, task.File)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, file)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//fmt.Printf(&quot;Read file %v\n&quot;, file)</span><br>&#125;<br><br>dec := json.NewDecoder(f)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> kv KeyValue<br><span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>intermediate = <span class="hljs-built_in">append</span>(intermediate, kv)<br>&#125;<br>&#125;<br><br>sort.Sort(ByKey(intermediate))<br><br>res := <span class="hljs-built_in">make</span>([]KeyValue, <span class="hljs-number">0</span>)<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(intermediate) &#123;<br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;<br>j++<br>&#125;<br>values := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;<br>values = <span class="hljs-built_in">append</span>(values, intermediate[k].Value)<br>&#125;<br><br>output := reducef(intermediate[i].Key, values)<br>res = <span class="hljs-built_in">append</span>(res, KeyValue&#123;intermediate[i].Key, output&#125;)<br>i = j<br>&#125;<br><br><span class="hljs-comment">// write to file</span><br>tempFile, err := ioutil.TempFile(reducefilepath, <span class="hljs-string">&quot;mr-tmp&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot create temp file&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, kv := <span class="hljs-keyword">range</span> res &#123;<br>fmt.Fprintf(tempFile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, kv.Key, kv.Value)<br>&#125;<br><br><span class="hljs-comment">//index := task.File[len(task.File)-1]</span><br>lastChar := <span class="hljs-type">string</span>(task.File[<span class="hljs-built_in">len</span>(task.File)<span class="hljs-number">-1</span>])<br>tmpName := fmt.Sprintf(<span class="hljs-string">&quot;mr-out-%v&quot;</span>, lastChar)<br>err = os.Rename(tempFile.Name(), tmpName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot rename file&quot;</span>)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Reduce task done&quot;</span>)<br><br><span class="hljs-comment">// reduce tasks done</span><br>reduceTasksDone(reducefilepath + tmpName)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241225155826.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.824</tag>
      
      <tag>Distributed System</tag>
      
      <tag>Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824-lecture4: Consistency, Linearizability</title>
    <link href="/2024/12/25/MIT-6-824-lecture4-Consistency-Linearizability/"/>
    <url>/2024/12/25/MIT-6-824-lecture4-Consistency-Linearizability/</url>
    
    <content type="html"><![CDATA[<h1 id="MIT-6-824-lecture4-Consistency-Linearizability"><a href="#MIT-6-824-lecture4-Consistency-Linearizability" class="headerlink" title="MIT-6.824-lecture4: Consistency, Linearizability"></a>MIT-6.824-lecture4: Consistency, Linearizability</h1><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><h3 id="Testing-Distributed-Systems-for-Linearizability"><a href="#Testing-Distributed-Systems-for-Linearizability" class="headerlink" title="Testing Distributed Systems for Linearizability"></a><a href="https://anishathalye.com/testing-distributed-systems-for-linearizability/">Testing Distributed Systems for Linearizability</a></h3><p>分布式系统的正确实现颇具挑战性，因为它们必须应对并发和故障。网络可能会延迟、重复、重新排序甚至丢弃数据包，而机器也可能随时发生故障。即便设计在理论上被证明是正确的，在实际实现中仍然难以避免那些微妙的错误。</p><p>除非我们选择使用形式化方法¹，否则如果我们希望确保实现是正确的，就必须对系统进行测试。然而，测试分布式系统同样充满挑战。并发性和不确定性使得在测试中捕捉错误变得困难，尤其是当那些最微妙的错误仅在某些不常见的情况下才会显现，例如同时发生机器故障或极端的网络延迟。</p><p>¹ 形式化方法：指使用数学模型和方法来验证系统正确性的一种技术。</p><h4 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h4><p>在我们讨论如何测试分布式系统的正确性之前，首先需要明确“正确”的含义。即便是看似简单的系统，精确地描述系统应该如何运行也是一个复杂的过程²。</p><p>以一个简单的键值存储系统为例，类似于etcd，它将字符串映射到字符串，并支持两种操作：Put(key, value) 和 Get(key)。首先，我们考虑它在顺序执行情况下的行为。</p><p>² 复杂的过程：指定义系统行为时需要考虑多种因素和细节，以确保描述的准确性和全面性。</p><h4 id="Sequential-Specifications"><a href="#Sequential-Specifications" class="headerlink" title="Sequential Specifications"></a>Sequential Specifications</h4><p>我们可能对键值存储在顺序操作下的行为有一个直观的理解：Get操作必须反映所有先前Put操作的结果。例如，我们可以执行一个Put(“x”, “y”)，然后随后的Get(“x”)应该返回”y”。如果操作返回了例如”z”，那就是不正确的。</p><p>比起用英语描述，我们可以将键值存储的规范写成可执行的代码，这样更加正式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KVStore</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._data = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-variable language_">self</span>._data[key] = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._data.get(key, <span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>这段代码虽然简短，但它涵盖了所有重要的细节：初始状态、操作如何修改内部状态，以及键值存储调用返回的值。规范还明确了当Get()被调用在一个不存在的键上时会发生什么，但总的来说，它与我们直观的键值存储定义是一致的。</p><h4 id="Linearizability"><a href="#Linearizability" class="headerlink" title="Linearizability"></a>Linearizability</h4><p>接下来，我们考虑键值存储在并发操作下的行为。需要注意的是，顺序执行的规范并没有告诉我们并发操作下会发生什么。例如，顺序规范并没有说明在以下场景中键值存储的行为：</p><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241220155159.png"></p><p>在这种情况下，Get(“x”)操作应该返回什么值并不明显。直观上，我们可能会说，由于Get(“x”)与Put(“x”, “y”)和Put(“x”, “z”)是并发的，它可以返回任意一个值，甚至是””。如果我们有一个场景，另一个客户端在很久之后执行了Get(“x”)，我们可能会说该操作必须返回”z”，因为这是最后一次写入的值，而最后一次写操作并没有与其他写操作并发。</p><p>我们基于顺序规范，使用一种称为<strong>线性一致性</strong>的一致性模型来正式指定并发操作的正确性。在线性一致性系统中，<strong>每个操作看起来都是原子性地且瞬时地在调用和响应之间的某个时间点执行</strong>。除了线性一致性之外，还有其他一致性模型，但许多分布式系统提供了线性一致性的行为：线性一致性是一种强一致性模型，因此在其基础上构建其他系统相对容易。</p><p>考虑一个包含键值存储操作的调用和返回值的历史示例：</p><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241220155443.png"></p><p>这个历史是线性一致的。我们可以通过显式地为所有操作找到线性化点（在下图中用橙色标出）来证明这一点。由此产生的顺序历史是：Put(“x”, “0”)，Get(“x”) -&gt; “0”，Put(“x”, “1”)，Get(“x”) -&gt; “1”，这是相对于顺序规范的正确历史。</p><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241220155539.png"></p><p>相比之下，这个历史不是线性一致的：</p><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241220155724.png"></p><p>这个历史没有相对于顺序规范的线性化：我们无法为这个历史中的操作分配线性化点。我们可以从客户端1、2和3的操作开始分配线性化点，但随后将无法为客户端4分配线性化点：它将观察到一个陈旧的值。同样，我们可以从客户端1、2和4的操作开始分配线性化点，但客户端2的操作的线性化点将在客户端4的操作开始之后，然后我们将无法为客户端3分配线性化点：它合法地只能读取””或”0”。</p><h4 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h4><p>有了对正确性的明确定义，我们就可以思考如何测试分布式系统。通常的方法是在随机注入故障（如机器故障和网络分区）的情况下测试系统的正确操作。我们甚至可以模拟整个网络，从而实现诸如造成极长网络延迟等操作。由于测试是随机的，我们希望多次运行这些测试，以确保系统实现的正确性。</p><h4 id="Ad-hoc-testing"><a href="#Ad-hoc-testing" class="headerlink" title="Ad-hoc testing"></a>Ad-hoc testing</h4><p>我们如何实际测试系统的正确操作呢？对于最简单的软件，我们通过输入输出用例进行测试，例如assert(expected_output &#x3D;&#x3D; f(input))。我们也可以对分布式系统采用类似的方法。例如，对于我们的键值存储，我们可以编写以下测试，其中多个客户端并行地对键值存储执行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> client_id = <span class="hljs-number">0.</span><span class="hljs-number">.10</span> &#123;<br>    spawn thread &#123;<br>        <span class="hljs-keyword">for</span> i = <span class="hljs-number">0.</span><span class="hljs-number">.1000</span> &#123;<br>            value = rand()<br>            kvstore.put(client_id, value)<br>            <span class="hljs-keyword">assert</span>(kvstore.get(client_id) == value)<br>        &#125;<br>    &#125;<br>&#125;<br>wait <span class="hljs-keyword">for</span> threads<br></code></pre></td></tr></table></figure><p>如果上述测试失败，那么键值存储显然不是线性一致的。然而，这个测试并不够全面：存在一些非线性一致的键值存储系统会始终通过这个测试。</p><h4 id="Linearizability-1"><a href="#Linearizability-1" class="headerlink" title="Linearizability"></a>Linearizability</h4><p>更好的测试方法是让并行客户端执行完全随机的操作，例如反复调用<code>kvstore.put(rand(), rand())</code>和<code>kvstore.get(rand())</code>，可能限制在一个小的键集合上以增加竞争。但在这种情况下，我们如何确定什么是“正确”的操作呢？在更简单的测试中，每个客户端操作的是不同的键，因此我们可以准确预测输出。</p><p>当客户端并发地操作同一组键时，事情变得更加复杂：我们无法预测每个操作的输出，因为答案并不唯一。因此，我们必须采用另一种方法：通过记录系统上所有操作的历史，然后检查该历史是否相对于顺序规范是线性一致的，来测试系统的正确性。</p><h5 id="Linearizability-Checking"><a href="#Linearizability-Checking" class="headerlink" title="Linearizability Checking"></a>Linearizability Checking</h5><p>线性一致性检查器将顺序规范和并发历史作为输入，并运行决策程序来检查历史是否相对于规范是线性一致的。</p><h5 id="NP-Completeness"><a href="#NP-Completeness" class="headerlink" title="NP-Completeness"></a>NP-Completeness</h5><p>不幸的是，线性一致性检查是NP完全的。证明其实相当简单：我们可以证明线性一致性检查属于NP，并且可以证明一个NP难问题可以归约为线性一致性检查。显然，线性一致性检查属于NP：给定一个线性化点（即所有操作的线性化点），我们可以在多项式时间内检查它是否是相对于顺序规范的有效线性化。</p><p>为了证明线性一致性检查是NP难的，我们可以将子集和问题归约为线性一致性检查。回顾一下，在子集和问题中，我们给定一个非负整数集合 $S &#x3D; { s_1, s_2, … , s_n }$ 和一个目标值$t$,我们需要确定是否存在一个子集 $S$ 的和等于<br>$t$。我们可以将这个问题归约为线性一致性检查，如下所示。考虑以下顺序规范：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._total = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>._total += value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._total<br></code></pre></td></tr></table></figure><p>并考虑以下历史：</p><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241220162127.png"></p><p>这个历史是线性一致的，当且仅当子集和问题的答案是“是”。如果历史是线性一致的，那么我们可以取所有在<code>Get()</code>操作的线性化点之前的<code>Add(s_i)</code>操作，这些操作对应于一个子集中的元素 $s_i$，其和为 $t$。如果集合确实有一个子集的和为 $t$，那么我们可以通过让对应于该子集中元素 $s_i$的<code>Add(s_i)</code>操作在<code>Get()</code>操作之前发生，而其余操作在<code>Get()</code>操作之后发生，来构造一个线性化操作。</p><h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p>尽管线性一致性检查是NP完全的，但在实践中，它在小规模历史记录上可以很好地工作。线性一致性检查器的实现会接收一个可执行的规范和一个历史记录，并运行搜索程序来尝试构建一个线性化，使用一些技巧来限制搜索空间的大小。</p><p>现有的线性一致性检查器如Knossos，它被用于Jepsen测试系统中。不幸的是，当我尝试测试自己编写的分布式键值存储实现时，我发现Knossos无法检查我的历史记录。它似乎在小规模历史记录上工作得还可以，比如在只有几个并发客户端的情况下，总共大约有100个历史事件，但在我的测试中，我有数十个客户端生成了数千个事件的历史记录。</p><p>为了能够测试我的键值存储，我编写了Porcupine，一个用Go实现的快速线性一致性检查器。Porcupine检查历史记录是否相对于用Go编写的可执行规范是线性一致的。根据经验，Porcupine比Knossos快数千倍。我能够使用它来测试我的键值存储，因为它能够在几秒钟内检查包含数千个事件的历史记录。</p><h4 id="Effectiveness"><a href="#Effectiveness" class="headerlink" title="Effectiveness"></a>Effectiveness</h4><p>使用故障注入和线性一致性检查来测试线性一致的分布式系统是一种有效的方法。</p><p>为了比较临时测试和使用Porcupine进行线性一致性检查的效果，我尝试使用这两种方法测试我的分布式键值存储。我尝试在实现中引入不同类型的设计错误，例如会导致陈旧读取的修改，并检查哪些测试会失败。临时测试捕捉到了一些最明显的错误，但无法捕捉到更微妙的错误。相比之下，我无法引入任何一个线性一致性测试无法捕捉的正确性错误。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.824</tag>
      
      <tag>Distributed System</tag>
      
      <tag>Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.824-Intro</title>
    <link href="/2024/12/07/MIT-6-824-Intro/"/>
    <url>/2024/12/07/MIT-6-824-Intro/</url>
    
    <content type="html"><![CDATA[<h1 id="MIT-6-824-Intro"><a href="#MIT-6-824-Intro" class="headerlink" title="MIT 6.824-Intro"></a>MIT 6.824-Intro</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>学习分布式系统相关知识，系统性的补全相关概念知识，为找暑期实习和秋招做准备。</p><p>使用的一些学习资料如下：</p><ul><li>视频：<ul><li><a href="https://www.bilibili.com/video/BV1xyxpeaE4N/?spm_id_from=333.999.0.0&vd_source=38f9aebaf1256061110ac23dc426e576">MIT《分布式系统|MIT 6.824 Distributed Systems 2020》中英字幕</a></li></ul></li><li>课程主页：<a href="https://pdos.csail.mit.edu/6.824/schedule.html">Schedule</a></li><li>相关博客：<ul><li><a href="https://xiaodongq.github.io/2024/08/17/mit-6-824-1-overview-mapreduce/">MIT 6.824学习笔记</a></li><li><a href="https://www.qtmuniao.com/2020/02/29/6-824-video-notes-1/">MIT 6.824 2020 视频笔记</a></li></ul></li></ul><h2 id="2-学习方式"><a href="#2-学习方式" class="headerlink" title="2.学习方式"></a>2.学习方式</h2><ol><li>快速阅读下推荐论文。</li><li>打算先快速过一遍视频，对概念有个印象，每节课整理笔记。</li><li>把优质博客的内容过一过，查缺补漏。</li><li>争取将课程实验都完整的做一遍。</li></ol><h2 id="3-MapReduce论文笔记"><a href="#3-MapReduce论文笔记" class="headerlink" title="3. MapReduce论文笔记"></a>3. MapReduce论文笔记</h2><h3 id="3-1-编程模型"><a href="#3-1-编程模型" class="headerlink" title="3.1 编程模型"></a>3.1 编程模型</h3><p>MapReduce 编程模型的原理是：利用一个输入 key&#x2F;value pair 集合来产生一个输出的 key&#x2F;value pair 集合。</p><p>MapReduce 库的用户用两个函数表达这个计算： Map 和 Reduce：</p><ul><li><p>用户自定义的Map 函数接受一个输入的 key&#x2F;value pair 值，然后产生一个中间 key&#x2F;value pair 值的集合。MapReduce 库把所有具有相同中间 key 值 I 的中间 value 值集合在一起后传递给 Reduce 函数。</p></li><li><p>用户自定义的Reduce 函数接受一个中间 key 的值 I 和相关的一个 value 值的集合。Reduce 函数合并这些value 值，形成一个较小的 value 值的集合。</p></li></ul><p>类型表示：</p><ul><li>map(k1,v1) -&gt; list(k2,v2)。表示由输入得到中间输出，两者的key和value都在不同的域上，所以分别用k1&#x2F;k2、v1&#x2F;v2区分了</li><li>reduce(k2,list(v2)) -&gt;list(v2)。而reduce输出对应的key和value和上面的中间输出结果的域是相同的，也是用k2、v2表示</li></ul><p>示例：论文里有好几个示例，这里选取几个：</p><ul><li>计算 URL 访问频率：<ul><li>Map 函数处理日志中 web 页面请求的记录，然后输出(URL,1)。</li><li>Reduce 函数把相同URL的value值都累加起来，产生(URL,记录总数) 结果</li></ul></li><li>倒排索引：<ul><li>Map 函数分析每个文档输出一个(词,文档号)的列表</li><li>Reduce 函数的输入是一个给定词的所有(词，文档号)，排序所有的文档号，输出( 词, list(文档号) )。</li></ul></li><li>分布式排序：<ul><li>Map 函数从每个记录提取 key，输出(key,record)</li><li>Reduce 函数不改变任何的值。这个运算依赖分区机制和排序属性。</li></ul></li></ul><h3 id="3-2-总体执行流程"><a href="#3-2-总体执行流程" class="headerlink" title="3.2. 总体执行流程"></a>3.2. 总体执行流程</h3><p>通过将 Map 调用的输入数据自动分割为 M 个数据片段的集合， Map 调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。</p><p>使用分区函数将 Map 调用产生的中间 key 值分成 R 个不同分区（例如 hash(key) mod R）， Reduce 调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p><p>总体执行流程示意图：<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241207131746.png"></p><h2 id="4-视频笔记"><a href="#4-视频笔记" class="headerlink" title="4. 视频笔记"></a>4. 视频笔记</h2><h3 id="4-1-课程会讨论到的相关概念"><a href="#4-1-课程会讨论到的相关概念" class="headerlink" title="4.1 课程会讨论到的相关概念"></a>4.1 课程会讨论到的相关概念</h3><p>这门课是一门关于基础设施建设的课程。<br>基础设施建设通常包括：</p><ul><li>存储</li><li>通信</li><li>计算</li></ul><p>我们在建设分布式系统时，希望隐藏其分布式特性，使其看起来和用起来都像是单机系统，当然这是理想化的，很难实现。</p><p>针对这些抽象，我们会有一下几个topics：</p><ul><li>RPC：远程过程调用</li><li>Threads：多线程并发</li><li>Concurrency Control：数据一致性</li><li>Performance：更好的性能</li><li>Scalability：希望系统的性能随着设备拓展是线性的</li><li>Falut Toleran：分布式系统会极大程度增大错误的发生，所以容错机制非常重要。<ul><li>availability：在系统出现故障时仍能提供可用的服务，比如一个副本服务器故障，另一个副本可以提供服务。</li><li>recoverability：可以在出错后恢复正确的状态。  <ol><li>使用非易失性存储设备，记录日志等。</li><li>replication，存储多个副本。</li></ol></li></ul></li><li>Consistency：<ul><li>假设我们支持俩种操作<ul><li>put(k,v)</li><li>get(k) -&gt; v</li></ul></li><li>因为在分布式系统中有很多副本，所以会引出一致性问题，因此在系统可能存在很多不同版本的kv对。 <ul><li>强一致性：保证每次get都能拿到最新的数据  <ol><li>保证数据一致性的开销很大。</li></ol></li><li>弱一致性：不保证每次get都能拿到最新的数据<ol><li>当副本之间相隔很远，可以考虑保证弱一致性。为了保证俩个副本的独立性，一般不同的副本会保存在不同的物理位置上。</li></ol></li></ul></li></ul></li></ul><h3 id="4-2-MapReduce"><a href="#4-2-MapReduce" class="headerlink" title="4.2 MapReduce"></a>4.2 MapReduce</h3><p>MapReduce时Goole提出的一项工作，其背景是对TiB级别的数据进行计算。比如建立网页索引，进行排序等。所以Google希望使用大量的计算机去运行大量的任务。他们希望一个framwork让不同背景的工程师编写程序去将他们的计算任务分散到不同的计算机上进行计算。</p><p>示例：word count<br>Input 1 -&gt; Map a,1 b,1<br>Input 2 -&gt; Map     b,1<br>Input 3 -&gt; Map a,1     c,1  </p><p>收集<br>所有的a，1给一个reduce实例 -&gt; a,2<br>所有的b，1去一个reduce实例 -&gt; b,2<br>…   </p><p>示例：<br>Map(k,v)<br>函数输入k是文件名，v是文件内容，功能是把划分成不同的words，对于每个words：emit(word,1)</p><p>Reduce(k,v)<br>    emit(len(v))</p><p>几乎所有Map操作设计的数据都是在本地的而不需要网络通讯，否则网络通讯开销很大。但是所有的map产生发的结果还是需要集中到一个reduce实例所在的服务器上，通信开销还是很大。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.824</tag>
      
      <tag>Distributed System</tag>
      
      <tag>Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux File System (File operations)</title>
    <link href="/2024/12/07/Linux-File-System-File-operations/"/>
    <url>/2024/12/07/Linux-File-System-File-operations/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-File-System-File-operations"><a href="#Linux-File-System-File-operations" class="headerlink" title="Linux File System (File operations)"></a>Linux File System (File operations)</h1><p>inode结构主要有以下成员：<br><strong>&#x2F;&#x2F; 必须有的</strong>  </p><ul><li>mode：类型+权限</li><li>文件大小</li><li>引用计数</li><li>块地址</li></ul><p><strong>&#x2F;&#x2F; 肯定没有的</strong>  </p><ul><li>文件名：一个文件可以有多个文件名，文件的文件名不存在inode里</li></ul><p><strong>&#x2F;&#x2F; 可以有的</strong></p><ul><li>时间戳，一般不更新访问时间，维护设备寿命</li></ul><p><strong>inode number 在一个文件系统中是唯一的</strong>  </p><ul><li>硬链接不能跨文件系统  </li><li>软链接可以跨文件系统</li></ul><p><strong>硬链接（Hard Link）</strong>  </p><ul><li>定义：硬链接是指多个文件名指向同一个 inode（索引节点）。</li><li>特点：  <ul><li>共用 inode：所有硬链接共享相同的 inode 号。  </li><li>文件访问：无论通过哪个链接访问文件，都是访问同一个数据块。</li><li>限制：  <ul><li>不能链接目录，以防止形成循环结构。</li><li>不能跨文件系统，因为 inode 在不同文件系统中是独立的。</li></ul></li></ul></li></ul><p><strong>软链接（Symbolic Link 或 Symlink）</strong></p><ul><li>定义：软链接是一个独立的文件，内容是另一个文件的路径。  </li><li>特点：<ul><li>不同 inode：软链接有自己的 inode，指向目标文件的路径。</li><li>灵活性：可以链接目录和跨文件系统的文件。</li><li>依赖性：如果目标文件被删除或移动，软链接将失效（成为“断链”）。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241206155844.png"></li></ul></li></ul><h2 id="Two-files-opened-by-a-process"><a href="#Two-files-opened-by-a-process" class="headerlink" title="Two files opened by a process"></a>Two files opened by a process</h2><p>举一个例子：<br>假设web server正在写一个access.log<br>此时开发人员想看一下access.log，使用less access.log命令<br>因此打开<strong>俩次</strong>这个文件，生成俩个file table entries（打开一个文件就是一个file table entry）<br>但是只有一个inode entry，file size存在inode中，所以开发人员是可以看到access.log的变化的。 </p><p>后面也会细说，其实文件操作主要涉及三个表结构，文件描述符表、文件表和inode表。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241206160138.png"></p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>有三个层次：</p><ol><li>file descriptor table （每个进程一个的）</li><li>file entry table, w.file offset （全局）</li><li>indoe table, w&#x2F;file size （全局）</li></ol><p>文件状态通常在file table中，只有FD_CLOEXEC放在file descriptor table中.<br>图示一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌─────────────────────────────────────────────────────┐<br>│                   Process Table                      │<br>├─────────┬─────────┬─────────┬─────────┬────────────┤<br>│Process 1│Process 2│Process 3│   ...   │Process N   │<br>│  PID 1  │  PID 2  │  PID 3  │         │  PID N    │<br>│         │         │         │         │            │<br>│ fd[0]─┐ │ fd[0]─┐ │ fd[0]─┐ │         │ fd[0]─┐   │<br>│ fd[1]─┼─│►fd[1]─┼─│►fd[1]─┼─│►  ...   │ fd[1]─┼─┐ │<br>│ fd[2]─┘ │ fd[2]─┘ │ fd[2]─┘ │         │ fd[2]─┘ │ │<br>└─────────┴─────────┴─────────┴─────────┴────────────┘<br>           │                                        │<br>           ▼                                        ▼<br>┌─────────────────────────────────────────────────────┐<br>│                    File Table                        │<br>├─────────┬─────────┬─────────┬─────────┬────────────┤<br>│File Ptr1│File Ptr2│File Ptr3│   ...   │File PtrN   │<br>│f_count=2│f_count=1│f_count=3│         │f_count=1   │<br>│f_pos    │f_pos    │f_pos    │         │f_pos       │<br>│f_flags  │f_flags  │f_flags  │         │f_flags     │<br>│f_mode   │f_mode   │f_mode   │         │f_mode      │<br>└────┬────┴────┬────┴────┬────┴─────────┴─────┬──────┘<br>     │         │         │                     │<br>     ▼         ▼         ▼                     ▼<br>┌─────────────────────────────────────────────────────┐<br>│                   Inode Table                        │<br>├─────────┬─────────┬─────────┬─────────┬────────────┤<br>│Inode 1  │Inode 2  │Inode 3  │   ...   │Inode N    │<br>└─────────┴─────────┴─────────┴─────────┴────────────┘<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241206160752.png"></p><h2 id="open-2-twice-vs-open-2-then-dup-2-fork-2"><a href="#open-2-twice-vs-open-2-then-dup-2-fork-2" class="headerlink" title="open(2)twice vs. open(2) then dup(2)&#x2F;fork(2)"></a>open(2)twice vs. open(2) then dup(2)&#x2F;fork(2)</h2><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241206161158.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>file system</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux File System (Blocks and Block Groups)</title>
    <link href="/2024/11/18/Linux-File-System-Blocks-and-Block-Groups/"/>
    <url>/2024/11/18/Linux-File-System-Blocks-and-Block-Groups/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-File-System-Blocks-and-Block-Groups"><a href="#Linux-File-System-Blocks-and-Block-Groups" class="headerlink" title="Linux File System (Blocks and Block Groups)"></a>Linux File System (Blocks and Block Groups)</h1><p>BSD块大小的演变，从1K -&gt; 2K -&gt; 4K。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241120142439.png"></p><h2 id="Block-Allocation："><a href="#Block-Allocation：" class="headerlink" title="Block Allocation："></a><strong>Block Allocation：</strong></h2><ul><li>文件系统再分配空间的时候是以block为单位的而不是字节。</li><li>查询剩余空间的操作应该是在常数时间内完成的。</li><li>用Bitmap来管理空闲的block，一个block大小的bitmap可以管理8192个blocks。</li><li>元数据一般单独存在inode。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241120150848.png"></li></ul><h2 id="Block-Size"><a href="#Block-Size" class="headerlink" title="Block Size"></a><strong>Block Size</strong></h2><ul><li><p>块大小对性能影响比较明显。</p></li><li><p>块大意味着元数据开销较小，吞吐量更高些（why?）</p></li><li><p>块小意味着更多的空间节省。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241120151230.png"></p></li><li><p>扇区大小一般是4K。</p></li><li><p>现在的一些文件系统在创建时会根据扇区大小来设置blocksize</p></li><li><p>blocsize应该大于等于扇区size，否则对一个快操作load的扇区size不合理。</p></li><li><p>blocksize需要小于pagesize以完成正常的虚拟内存映射。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241120153411.png"></p></li></ul><h2 id="Max-filesystem-size"><a href="#Max-filesystem-size" class="headerlink" title="Max filesystem size"></a><strong>Max filesystem size</strong></h2><ul><li>文件系统最大大小是 blocksize * 2^ (block number bits)</li><li>最大容量的一个潜在限制是block group，其描述符必须放在一个block中，所以实际上最大不能超过256TiB。</li><li><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241120154620.png"></li></ul><h2 id="Block-Groups"><a href="#Block-Groups" class="headerlink" title="Block Groups"></a><strong>Block Groups</strong></h2><ul><li>8192个block会分为一个blocks，取决于存group描述幅的大小。</li><li>划分的主要目的是优化locality<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241122142105.png"></li></ul><h2 id="Group-Descriptor"><a href="#Group-Descriptor" class="headerlink" title="Group Descriptor"></a><strong>Group Descriptor</strong></h2><ul><li>仅凭group descriptor不能完整的得到一个block group的信息，可能确实这个group从那个blcok开始，有多少inode等</li><li>Ext2中的group descriptor是32B， Ext4拓展为64B。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241122144534.png"></li></ul><h2 id="Fragments-and-Clusters"><a href="#Fragments-and-Clusters" class="headerlink" title="Fragments and Clusters"></a>Fragments and Clusters</h2><ul><li>Ext2文件系统把Block继续切分为更小的Fragments。</li><li>Cluster相当于把block聚合在一起分配，用于给一些大文件分配空间。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241122144846.png"></li></ul><h2 id="Block-size-is-important-to-filesystem"><a href="#Block-size-is-important-to-filesystem" class="headerlink" title="Block size is important to filesystem"></a>Block size is important to filesystem</h2><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241122145305.png"></p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><h3 id="Q-Block-group-和-cluster的概念会不会有些重叠呢？"><a href="#Q-Block-group-和-cluster的概念会不会有些重叠呢？" class="headerlink" title="Q: Block group 和 cluster的概念会不会有些重叠呢？"></a>Q: Block group 和 cluster的概念会不会有些重叠呢？</h3><h3 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h3><ul><li>功能定位不同：<ul><li>block group是文件系统的管理单元,包含管理结构(inode表等)</li><li>cluster是文件存储的分配单元,纯粹用于数据存储</li></ul></li><li>使用场景不同：<ul><li>block group主要用于ext等现代文件系统</li><li>cluster概念早期在FAT文件系统中就有使用</li></ul></li><li>大小特征不同：  <ul><li>block group通常较大,包含多个blocks和管理结构</li><li>cluster大小相对较小,主要考虑存储效率</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>file system</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodingNotes(01)</title>
    <link href="/2024/11/17/CodingNotes-01/"/>
    <url>/2024/11/17/CodingNotes-01/</url>
    
    <content type="html"><![CDATA[<h1 id="岛屿系列题目"><a href="#岛屿系列题目" class="headerlink" title="岛屿系列题目"></a>岛屿系列题目</h1><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695.岛屿的最大面积</a></h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>最简单的想法</p><ol><li>有一个函数输入是某个为1的点，然后去找这个点所在岛屿的面积。</li><li>函数计算的方式是DFS，向四周遍历直到碰到0。</li><li>遍历所有为1的点取最大值。</li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>第一版code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> tmp =  <span class="hljs-built_in">islandSize</span>(grid, i, j);<br>                    ret = (tmp&gt;ret) ? tmp : ret;<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandSize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>  || x &gt;=grid.<span class="hljs-built_in">size</span>() || y&lt;<span class="hljs-number">0</span> || y&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(grid[x][y] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">islandSize</span>(grid, x<span class="hljs-number">+1</span>, y) + <span class="hljs-built_in">islandSize</span>(grid, x<span class="hljs-number">-1</span>, y)<br>                        + <span class="hljs-built_in">islandSize</span>(grid, x, y<span class="hljs-number">+1</span>) + <span class="hljs-built_in">islandSize</span>(grid, x, y<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这里没有考虑到重复访问的问题，没有将已经计数过的陆地置为0，陷入无限递归而导致栈溢出。<br>修改后的code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从0开始，因为面积不能是负数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">islandSize</span>(grid, i, j);<br>                    ret = std::<span class="hljs-built_in">max</span>(tmp, ret);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandSize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-comment">// 检查边界</span><br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= grid.<span class="hljs-built_in">size</span>() || y &lt; <span class="hljs-number">0</span> || y &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || grid[x][y] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 标记单元格为已访问</span><br>        grid[x][y] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 对相邻单元格进行递归调用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">islandSize</span>(grid, x + <span class="hljs-number">1</span>, y) + <span class="hljs-built_in">islandSize</span>(grid, x - <span class="hljs-number">1</span>, y)<br>                   + <span class="hljs-built_in">islandSize</span>(grid, x, y + <span class="hljs-number">1</span>) + <span class="hljs-built_in">islandSize</span>(grid, x, y - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1905-统计子岛屿"><a href="#1905-统计子岛屿" class="headerlink" title="1905. 统计子岛屿"></a><a href="https://leetcode.cn/problems/count-sub-islands/description/">1905. 统计子岛屿</a></h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><ol><li>同上题 不过dfs函数的返回值改为bool类型，基本思想是边遍历边判断。</li></ol><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid2[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid2[i][j] == <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">auto</span> tmp = <span class="hljs-built_in">isVaildIsland</span>(grid1, grid2, i, j);<br>                    <span class="hljs-keyword">if</span>(tmp) ret++;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVaildIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid2, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-comment">// 检查边界</span><br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= grid<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() || y &lt; <span class="hljs-number">0</span> || y &gt;= grid2[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// if(grid1[x][y] ^ grid2[x][y]) return false;</span><br><br>        <span class="hljs-keyword">if</span>(grid2[x][y]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 标记单元格为已访问</span><br>        grid2[x][y] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(grid1[x][y] == <span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//return false;</span><br>        &#125;<br>    <br>        <span class="hljs-keyword">auto</span> tmp1 = <span class="hljs-built_in">isVaildIsland</span>(grid1, grid2, x + <span class="hljs-number">1</span>, y);<br>        <span class="hljs-keyword">auto</span> tmp2 =  <span class="hljs-built_in">isVaildIsland</span>(grid1, grid2, x - <span class="hljs-number">1</span>, y);<br>        <span class="hljs-keyword">auto</span> tmp3 = <span class="hljs-built_in">isVaildIsland</span>(grid1, grid2, x, y + <span class="hljs-number">1</span>) ;<br>        <span class="hljs-keyword">auto</span> tmp4 =  <span class="hljs-built_in">isVaildIsland</span>(grid1, grid2, x, y - <span class="hljs-number">1</span>);<br>  <br>        <span class="hljs-keyword">return</span>  flag&amp;&amp;tmp1&amp;&amp;tmp2&amp;&amp;tmp3&amp;&amp;tmp4;<br>        <span class="hljs-comment">// return  tmp1&amp;&amp;tmp2&amp;&amp;tmp3&amp;&amp;tmp4;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一开始踩了几个坑</p><ol><li>首先是觉得grid1和grid2的不同时就返回false，显然当grid1&#x3D;&#x3D;1 &amp;&amp; grid2 &#x3D;&#x3D; 0 时是不成立的</li><li>其次是grid1 &#x3D;&#x3D; 0 &amp;&amp; grid2 &#x3D;&#x3D; 1时不能直接返回false，否则递归会直接中止。</li></ol><h2 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a><a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a></h2><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>先把所有和边界联通的陆地都沉了，然后再去统计剩余的陆地数量。</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;col;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][i]==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">turn2sea</span>(grid, <span class="hljs-number">0</span>, i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(grid[row<span class="hljs-number">-1</span>][i]==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">turn2sea</span>(grid, row<span class="hljs-number">-1</span>, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">turn2sea</span>(grid, i, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(grid[i][col<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">turn2sea</span>(grid, i, col<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>       <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;col;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    ret++;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">turn2sea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>|| y&lt;<span class="hljs-number">0</span>|| x&gt;=grid.<span class="hljs-built_in">size</span>() || y&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() ||grid[x][y]==<span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            grid[x][y]=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">turn2sea</span>(grid, x<span class="hljs-number">+1</span>,y);<br>            <span class="hljs-built_in">turn2sea</span>(grid, x<span class="hljs-number">-1</span>,y);<br>            <span class="hljs-built_in">turn2sea</span>(grid, x,y<span class="hljs-number">+1</span>);<br>            <span class="hljs-built_in">turn2sea</span>(grid, x,y<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br>    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>Leetcode</tag>
      
      <tag>isLand Problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux File System (Disk)</title>
    <link href="/2024/11/12/Linux-File-System-Disk/"/>
    <url>/2024/11/12/Linux-File-System-Disk/</url>
    
    <content type="html"><![CDATA[<p>本节主要介绍磁盘的结构<br>首先Disk是由磁道、扇区和磁头几个部分组成的，柱面其实是一个逻辑概念，是指某一个磁道在所有盘面上的位置构成的一个抽象的柱面。<br>一些参数的含义：</p><ul><li>7200PRM：7200转每分钟 </li><li>120Hz：一秒钟120转</li><li>转一圈是8.33ms</li><li>旋转延迟：把磁头移到指定扇区所耗时间的平均值。</li><li>seek time：移动磁头的时间（很多年没有优化过了）</li></ul><p>寻道时间是可以去优化的，比如电梯算法、本地命令重排等<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241118171238.png"></p><p><strong>简单了解一下本地命令重排（NCQ）</strong><br>NCQ（Native Command Queuing）是一种硬盘内置的I&#x2F;O优化技术。它允许硬盘控制器同时接收多个读写命令，并对这些命令进行智能重新排序，以获得最优的执行顺序。</p><p>主要工作原理：</p><p>硬盘缓存多个I&#x2F;O请求<br>分析这些请求的物理位置关系<br>重新安排执行顺序，最小化磁头移动距离<br>减少寻道时间和旋转延迟<br>这项技术主要用于提升机械硬盘的随机读写性能，特别是在多线程高并发访问场景下。</p><p>可以看出机械硬盘的吞吐量和磁头所在位置相关，靠外侧吞吐量高一些，内侧低一点。下面这张图的盘面都是25寸的。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241118191311.png"></p><p>对比一下盘面大小不同，转速相同，所以盘面大的线速度肯定快一些，自然吞吐量就高，盘面小的反之。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241118191727.png"></p><p>磁盘故障率和磁盘错误率</p><ul><li>故障率：表示硬盘完全失效或不可恢复损坏的概率</li><li>错误率：表示数据读写过程中出现位错误的概率</li></ul><p>磁盘的故障率还是比我理解的高很多的。包括磁盘本身和他的controller的故障率。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241118201020.png"></p><p>总的来说这节就是比较high level的介绍了磁盘的各种特性和一些指标，为后面介绍文件系统设计做了铺垫。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>file system</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux File System (Abstract)</title>
    <link href="/2024/11/11/Linux-File-System/"/>
    <url>/2024/11/11/Linux-File-System/</url>
    
    <content type="html"><![CDATA[<p>这个系列的讲座主要是学习陈硕大佬的<a href="https://space.bilibili.com/1356949475/channel/collectiondetail?sid=1211802">Linux文件系统系列视频</a>，补充自己在文件系统部分知识的欠缺。</p><p>Kenneth Lane Thompson 在文件系统的基础上用了三周分别实现了一个editor、assembler和shell实现了操作系统Unix。可见现代Linux系统中一切皆文件的哲学其实来源于此，并不是说先有操作系统，再为其设计文件系统，而是恰恰相反现有文件系统，在此基础上搭建操作系统，可见文件系统的重要性。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241111163350.png"></p><p>文件的内容由用户决定，而不是为文件预定义类型。<br>10个最核心的系统调用：</p><ul><li>open&#x2F;close&#x2F;(create)： 打开，关闭文件。</li><li>read&#x2F;write&#x2F;lseek：支持读、写、随机读写。</li><li>fstat&#x2F;ftruncate：返回文件元数据、截断文件</li><li>unlink&#x2F;mkdir&#x2F;dup…：减少引用计数、创建目录、复制文件操作符<br>这些系统调用和文件定义抽象了文件这个概念。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241111163650.png"></li></ul><p>接下来就是文件系统，其实抽象出来就是文件名到文件内容的映射。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241111164242.png"></p><p>Unix文件系统对文件系统有更具体的抽象，其中最核心的概念就是inode。inode是文件名和文件内容的一个桥梁。<br>重要变量：</p><ul><li><code>typedef uint32_t inode_num_t</code>实际上规定了文件系统最多可以有多少个文件，相当于一个主键。</li><li><code>Map&lt;string, inode_num_t&gt; dirs</code> 从文件路径到inode的映射</li><li><code>Map&lt;inode_num_t, string&gt; files</code> inode到文件内容的映射<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241111203614.png"></li></ul><p>块设备, 现在的机械硬盘大部分以4KiB为一个块单位。（只能按照1KiB或4KiB访问）<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241111212710.png"></p><p>文件系统的功能实际上是把块设备”变“为一系列操作文件的API。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241112083807.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>file system</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastCommit论文精读</title>
    <link href="/2024/11/05/FastCommit%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"/>
    <url>/2024/11/05/FastCommit%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>FastCommit</strong>是一种文件系统的日志机制，主要针对传统物理日志方式（JBD2 ..）等存在的高磁盘写带宽占用、高IO占用和上下文切换开销等问题进行优化。  </p><p>核心<strong>desgin</strong>：  </p><ul><li><strong>compact journaling</strong></li><li><strong>selective flusing</strong></li><li><strong>inline journaling</strong></li></ul><p><strong>FastCommit</strong>相比于JBD2 吞吐量提升120%并成功整合到Upstream Linux Kernel中。</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Physical-Journaling-vs-Logical-Journaling"><a href="#Physical-Journaling-vs-Logical-Journaling" class="headerlink" title="Physical Journaling vs Logical Journaling"></a>Physical Journaling vs Logical Journaling</h2><p>逻辑日志只记录文件或者目录的修改操作。物理日志记录了变化的元数据（bitmaps, directory entries…）， 并在checkpoint或者crash recovery的时候写回disk。  </p><p>大部分文件系统都是用了物理日志，因为物理日志方柏霓使用，文件系统格式不敏感并且容易维护。但是物理日志一般体量较大</p><p>逻辑日志的size较小并且记录日志的速度快，但是他的崩溃恢复机制比较复杂并且很慢（因为需要对文件操作进行重放）。</p><h2 id="JBD2-Journaling"><a href="#JBD2-Journaling" class="headerlink" title="JBD2 Journaling"></a>JBD2 Journaling</h2><p>JBD2是最常用的物理日志方式，被大多数文件系统采用。它通过提交一个事务的方式来对多个块进行以此更新。在checkpoint可以异步的将其存储的元数据写入磁盘。</p><h2 id="NFS-protocol-and-semantics"><a href="#NFS-protocol-and-semantics" class="headerlink" title="NFS protocol and semantics."></a>NFS protocol and semantics.</h2><h2 id="NFS-protocol-and-semantics-1"><a href="#NFS-protocol-and-semantics-1" class="headerlink" title="NFS protocol and semantics."></a>NFS protocol and semantics.</h2><h3 id="Close-to-Open-Consistency-Mechanism"><a href="#Close-to-Open-Consistency-Mechanism" class="headerlink" title="Close-to-Open Consistency Mechanism"></a>Close-to-Open Consistency Mechanism</h3><p>NFS（Network File System）中的 ### ### Close-to-Open Consistency Mechanism</p><p>NFS（Network File System）中的 close-to-open 机制是一种确保文件一致性的策略。其主要目标是在文件关闭（close）和重新打开（open）之间保持文件数据的一致性。具体包括以下几个步骤：</p><ol><li><p><strong>文件关闭（Close）</strong>：</p><ul><li>当客户端关闭一个文件时，NFS 客户端会将所有对该文件的修改（写操作）同步到服务器，确保服务器上的文件数据是最新的。</li></ul></li><li><p><strong>文件打开（Open）</strong>：</p><ul><li>客户端重新打开文件时，NFS 客户端会检查服务器上的文件是否有更新。如果服务器上的文件自上次客户端缓存以来发生变化，客户端会丢弃缓存，并从服务器重新读取文件数据。</li></ul></li></ol><p>通过该机制，NFS 保证文件在关闭和重新打开之间的修改能够被检测和同步，从而提高了文件系统的一致性。这在多客户端同时访问和修改同一文件的分布式环境中尤为重要。</p><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><h2 id="JBD2多次频繁的commit导致效率低下"><a href="#JBD2多次频繁的commit导致效率低下" class="headerlink" title="JBD2多次频繁的commit导致效率低下"></a>JBD2多次频繁的commit导致效率低下</h2><p>JBD2每5秒就要提交一次并且每次都会触发fsync。<br>每次JBD2提交至少存储3个块（4KB）——一个描述符块（关于提交中其他块的元数据），至少一个已更改的元数据块，以及一个表示提交结束的提交标记块。<br>每次JBD2提交至少需要两个写IOs——一个写描述符块以及已更改的元数据块到磁盘，另一个写提交标记块。</p><h2 id="NFS的一致性保证不适用于JBD2"><a href="#NFS的一致性保证不适用于JBD2" class="headerlink" title="NFS的一致性保证不适用于JBD2"></a>NFS的一致性保证不适用于JBD2</h2><p>NFS 的异步模式语义会将每个 <code>create + append + close</code> 操作转换为 <code>create + append + close + fsync</code>。因此，对于 JBD2 而言，默认的 NFS 不会频繁地将大型提交转换为 <code>fsync-on-close</code>。然而，如果使用的是同步模式的 NFS，上述操作会被转换为 <code>create + fsync</code>、<code>append + fsync</code> 和 <code>close + fsync</code>，这就导致了性能上的异常情况。</p><h2 id="与云环境的收费机制之间的矛盾"><a href="#与云环境的收费机制之间的矛盾" class="headerlink" title="与云环境的收费机制之间的矛盾"></a>与云环境的收费机制之间的矛盾</h2><p>高字节和IO开销：JBD2在进行大量元数据操作时，会产生大量的字节和IO开销，尤其是在频繁的fsync调用下。这在云环境中会导致更高的成本，因为云存储通常基于使用量收费（如IOPS和吞吐量）。<br>成本影响：由于JBD2的高开销，用户在云中使用Ext4文件系统时，可能需要购买更多的存储性能（如更高的IOPS和带宽）以满足性能需求，从而增加了整体成本。</p><h1 id="Main-Idea"><a href="#Main-Idea" class="headerlink" title="Main Idea"></a>Main Idea</h1><p>FastCommit的目标是减少日志的byte和IO的overhead，以此来减少资源消耗并提高用户的使用体验。<br>他的核心idea就是混合使用logical journaling 和 physical journaling。FastCommit不修改JBD2每5秒commit一次的设计，但是在这5s中间，FastCommit会去尝试进行logical journaling，但是如果无法进行logical journaling（通常是一些比较少见的操作比如文件系统的resize等），则退回到传统的JBD2的方式。</p><h1 id="Desgin"><a href="#Desgin" class="headerlink" title="Desgin"></a>Desgin</h1><h2 id="Hybrid-Jounraling"><a href="#Hybrid-Jounraling" class="headerlink" title="Hybrid Jounraling"></a>Hybrid Jounraling</h2><p>像JBD2这样的物理日志被设计为在块级别提供日志记录。另一方面，逻辑日志记录文件和目录操作，这些操作位于inode级别，而不是块级别。因此，FASTCOMMIT的混合日志需要在两个级别上都支持日志记录和恢复，而不会造成分层冲突。  </p><h3 id="The-FASTCOMMIT-commit"><a href="#The-FASTCOMMIT-commit" class="headerlink" title="The FASTCOMMIT commit"></a>The FASTCOMMIT commit</h3><p>首先介绍一下在俩次slow commit之间FastCommit做了什么<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241112105423.png"><br>这里作者举了例子来说明FastCommit的操作过程：</p><ol><li>首先FastCommit维护了俩个In-Memory的List：L<sub>I</sub>和L<sub>D</sub>，L<sub>I</sub>用来记录inode的更新；L<sub>D</sub>用来记录目录条目的更新。</li><li>假设有个线程T1创建了一个新的文件F1，那么像L<sub>I</sub>中插入新分配的inode；向L<sub>D</sub>中插入新的目录条目。</li><li>假设后续线程T2向文件F1中追加了数据，这里和传统的JBD2的区别就出现了：JBD2会存储完整的被修改的元数据快的副本，而FastCommit进存储被修改的数据块的中被涉及的部分的偏移量。如图中所示i1更新为i1’。</li><li>随后线程T2创建新文件F2，对应的inode和目录条目也被更新进俩个list中。</li><li>随后线程T1发起fsync操作，FastCommit遍历俩个list，将所有的更新到宝成一个FCLog并将其存储到FC area。通常一个FCLog可以容纳进一个4KiB的磁盘块中。</li></ol><h3 id="FCLog"><a href="#FCLog" class="headerlink" title="FCLog"></a>FCLog</h3><p><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241112105439.png"><br>前面提到，FastCommit在线程调用fsync后会把所有文件更新大包围一个FCLog并写入到FC area，注意这里FC area并没有新开辟任何空间，而是在JBD2的原本存放日志的位置占用了15%的space，所以没有引入额外的overhead。</p><p>每个FCLog记录了多个文件的更新操作，是由多个FCTag组成的，每个FCTag包含三个部分：</p><ul><li>type(2 Bytes)</li><li>length(2 Bytes)</li><li>value(variable length)</li></ul><p>FCLog总是以头标记开始，以尾标记结束，它们都占用12个字节。head标记标志着FASTCOMMIT提交的开始，并包含前一个慢提交的提交ID，之后应该重播这个FCLog以备恢复。tail标记标志着FCLog的结束（类似于传统JBD2提交中的提交块）。</p><p>注意大部分的文件操作都可以用8个FCTags来描述：</p><ol><li>HEAD: 标志一个FCLog的开始</li><li>ADD_RANGE: 在一个文件中添加数据</li><li>DEL_RANGE: 在一个文件中删除数据</li><li>CREAT: 创建一个文件</li><li>LINK: 符号链接或重命名文件 </li><li>UNLINK: 删除一个文件</li><li>INODE: 存储一个inode </li><li>TAIL: FCLog的结尾并包含一个checksum</li></ol><p>可以举几个例子来说明如何用FCTags来记录文件操作。</p><ol><li>文件创建&#x2F;删除：这个操作创建了一个包含俩个FCTags的FCLog。CREATE和INODE，CREATE表明这是一个文件创建操作，INODE则存储了一个新的Inode的副本。</li><li>向文件中追加内容：我们考虑向一个叫做foo的文件中添加4KiB的数据，这个操作会产生一下的FCTags：<ol><li>HEAD Tags (12Bytes)</li><li>ADD_RANGE FCTag (20 bytes)表示在文件中添加了一个逻辑块地址为1、物理块地址为1000、大小为1块的新区段。</li><li>INODE FCTag (136 bytes):文件inode的最新副本。</li><li>TAIL FCTag (12 bytes).</li></ol></li></ol><p>整个FCLog的开销是168Bytes，首先说一下inode的136Bytes的构成：<br><code>INODE FCTag</code> 的大小为 136 字节，主要是由于 inode 结构中包含了多个字段，每个字段占用一定的字节数。以下是详细的计算过程：</p><p><strong>inode 结构组成及字节分配</strong>：</p><ol><li><strong>文件类型和权限（mode）</strong>：4 字节</li><li><strong>用户ID（UID）</strong>：4 字节</li><li><strong>组ID（GID）</strong>：4 字节</li><li><strong>文件大小（size）</strong>：8 字节</li><li><strong>访问时间（atime）</strong>：8 字节</li><li><strong>修改时间（mtime）</strong>：8 字节</li><li><strong>更改时间（ctime）</strong>：8 字节</li><li><strong>链接计数（nlink）</strong>：4 字节</li><li><strong>块指针（block pointers）</strong>：<ul><li>直接指针：48 字节（假设有12个直接指针，每个指针4字节）</li><li>间接指针：32 字节（例如，单、双、三重间接指针，每个指针4字节）</li></ul></li><li><strong>扩展属性（extended attributes）</strong>：16 字节</li><li><strong>校验和（checksum）</strong>：8 字节</li></ol><h3 id="具体计算"><a href="#具体计算" class="headerlink" title="具体计算"></a>具体计算</h3><table><thead><tr><th>字段</th><th>字节数</th></tr></thead><tbody><tr><td>mode</td><td>4</td></tr><tr><td>UID</td><td>4</td></tr><tr><td>GID</td><td>4</td></tr><tr><td>size</td><td>8</td></tr><tr><td>atime</td><td>8</td></tr><tr><td>mtime</td><td>8</td></tr><tr><td>ctime</td><td>8</td></tr><tr><td>nlink</td><td>4</td></tr><tr><td>块指针（直接 + 间接）</td><td>80</td></tr><tr><td>扩展属性</td><td>16</td></tr><tr><td>校验和</td><td>8</td></tr><tr><td><strong>总计</strong></td><td><strong>136</strong></td></tr></tbody></table><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><strong>块指针</strong>：通常，一个 inode 包含多个直接和间接块指针，用于指向文件的数据块。假设有12个直接指针，每个4字节，共48字节；再加上单、双、三重间接指针，每个4字节，共32字节，总计80字节。</li><li><strong>扩展属性</strong>：用于存储文件的附加信息，如SELinux标签等，占用16字节。</li><li><strong>校验和</strong>：用于确保 inode 数据的一致性和完整性，占用8字节。</li></ul><p>通过以上字段的累加，总大小为136字节，因此 <code>INODE FCTag</code> 需要136字节来记录 inode 的最新副本。</p><p>而同样的操作JBD2则需要24KiB来完成。这是因为：</p><ol><li>一个文件描述快(4KiB)</li><li>修改的元数据快：<ol><li>inode(4KiB)</li><li>目录entry(4KiB)</li><li>块位图(4KiB)</li><li>扩展树块(4KiB)</li></ol></li><li>提交标记块(4KiB)</li><li>在文件中删除数据：FastCommit只记录被删除文件所属的一个区段在DEL_RANGE中。当FASTCOMMIT记录了DEL_RANGE标签中的逻辑块范围后，删除操作会更新inode以反映文件当前的块分配状态。在恢复过程中，可以通过解析最新的inode状态来推断出哪些物理块已被释放或删除，而无需在日志中显式存储这些物理块地址。</li><li>重命名文件：假设文件“&#x2F;foo”要重命名为“&#x2F;bar”。让我们假设目录条目“&#x2F;foo”与磁盘上的inode i10相关联。重命名操作将生成以下FCTags：<ol><li>HEAD FCTag (12 bytes). </li><li>LINK FCTag that records the association of “bar” with i10 (16 bytes). </li><li>UNLINK FCTag that records the disassociation of the directory entry “foo” from i10 (16 bytes). </li><li>INODE FCTag that records the most recent copy of inode i10 (136 bytes). </li><li>TAIL FCTag (12 bytes).<br>因此，rename的整个FASTCOMMIT提交被捕获为192字节。在JBD2中，重命名操作需要存储7个大小为4KB的块，每个块总共28KB。</li></ol></li></ol><p>当将文件 &#x2F;foo 重命名为 &#x2F;bar 时，涉及以下操作：</p><ol><li>描述符块（4KB）：<br>记录此次重命名操作的基本信息。</li><li>修改的元数据块（4KB × 5 &#x3D; 20KB）：<ol><li>inode 块：更新 &#x2F;foo 和 &#x2F;bar 的 inode 信息。</li><li>目录条目块：更新旧目录 &#x2F;foo 中的条目，移除对 inode i10 的引用。</li><li>新目录条目块：在新目录 &#x2F;bar 中创建新的目录条目，指向 inode i10。</li><li>块位图块（Block Bitmap）：如果有块分配或释放，需要更新块位图。</li><li>扩展树块（Extent Tree Block）：如果涉及扩展属性，还需要更新扩展树。</li></ol></li><li>提交标记块（4KB）：</li></ol><h2 id="Selective-Flushing"><a href="#Selective-Flushing" class="headerlink" title="Selective Flushing"></a>Selective Flushing</h2><p>Cache flush命令强制磁盘将写入易失性Cache中的数据全部写入非易失性介质。文件系统广泛使用刷新来保证数据的一致性。但是，如果日志子系统在决定何时进行刷新时不小心，它可能会将数据刷新到磁盘，而这些数据本可以安全地在磁盘缓存中驻留更长时间。</p><p>以JBD2为例，JBD2首先用写入实际数据和文件操作设计的元数据，为了确保数据全部持久化就需要一次flush，之后还需要写一个commit block来标志这个commit结束，但这里不需要flush而是用一个FUA跳过页缓存直接写入磁盘。但注意FUA一次只能写入一个block。</p><p>我的理解是，FastCommit设计的FCLog大部分情况下都可以容纳进一个block里面，那么就可以直接用FUA写入从而避免flush的时间，对于那些无法用logical journal的情况就退回到JBD2的机制，所以叫做selective flushing。</p><h2 id="Inline-Jounarling"><a href="#Inline-Jounarling" class="headerlink" title="Inline Jounarling"></a>Inline Jounarling</h2><p>这里感觉论文写的并不是很清楚，大概意思是说FastCommit可以把journal做的很小，然后就不需要切换到JBD2的线程来进行commit，因此少了俩次上下文切换的开销，换来了一些吞吐量。</p>]]></content>
    
    
    <categories>
      
      <category>论文精读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JBD2</tag>
      
      <tag>Journaling</tag>
      
      <tag>FastCommit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git源码解析-环境搭建</title>
    <link href="/2024/11/03/git%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/11/03/git%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Why-How"><a href="#Why-How" class="headerlink" title="Why? How?"></a>Why? How?</h1><h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>做这件事的起因是在和导师做的一篇论文想去argue一个场景，场景下涉及到去了解git的delta compression机制，所以这个系列的文章核心是弄清楚git的压缩相关机制，当然如果工作流有涉及那么也会一起研究下。</p><h2 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h2><p>在本地环境从源码编译git的源代码。</p><h3 id="1-获取源代码"><a href="#1-获取源代码" class="headerlink" title="1. 获取源代码"></a>1. 获取源代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/git/git.git<br><span class="hljs-built_in">cd</span> git<br></code></pre></td></tr></table></figure><h3 id="2-配置编译选项"><a href="#2-配置编译选项" class="headerlink" title="2. 配置编译选项"></a>2. 配置编译选项</h3><p>在编译之前，可以配置安装路径和其他选项。为了不覆盖系统自带的Git，建议将编译后的Git安装到 &#x2F;usr&#x2F;local 或者其他自定义目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make configure<br>./configure --prefix=/home/Helix/repos/myGit/<br></code></pre></td></tr></table></figure><p>–prefix&#x3D;&#x2F;usr&#x2F;local 指定安装路径为 &#x2F;usr&#x2F;local，这样不会覆盖系统自带的Git（通常安装在 &#x2F;usr&#x2F;bin&#x2F;git）。</p><h3 id="3-编译和安装Git"><a href="#3-编译和安装Git" class="headerlink" title="3. 编译和安装Git"></a>3. 编译和安装Git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">make all<br><br><span class="hljs-comment"># 可选：运行测试确保一切正常</span><br>make <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 安装到指定目录</span><br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><h3 id="4-创建别名"><a href="#4-创建别名" class="headerlink" title="4. 创建别名"></a>4. 创建别名</h3><p>创建一个自定义别名即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加到zshrc文件中</span><br><span class="hljs-built_in">alias</span> mygit=<span class="hljs-string">&#x27;/home/Helix/repos/myGit/bin/git&#x27;</span><br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>之后使用mygit就可以执行编译后的版本，方便调试。</p><h3 id="5-编写脚本方便后续编译"><a href="#5-编写脚本方便后续编译" class="headerlink" title="5. 编写脚本方便后续编译"></a>5. 编写脚本方便后续编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 定义安装前缀</span><br>PREFIX=/home/junwu202322080121/Helix/repos/myGit<br><br><span class="hljs-comment"># 导航到 Git 源代码目录</span><br><span class="hljs-built_in">cd</span> /home/junwu202322080121/Helix/repos/git || <span class="hljs-built_in">exit</span><br><br><span class="hljs-comment"># 拉取最新更改（如果需要）</span><br><span class="hljs-comment"># git pull origin master</span><br><br><span class="hljs-comment"># 配置编译选项（如果尚未配置）</span><br><span class="hljs-keyword">if</span> [ ! -f Makefile ]; <span class="hljs-keyword">then</span><br>    make configure<br>    ./configure --prefix=<span class="hljs-variable">$&#123;PREFIX&#125;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 编译</span><br>make -j$(<span class="hljs-built_in">nproc</span>)<br><br><span class="hljs-comment"># # 运行测试（可选）</span><br><span class="hljs-comment"># make test</span><br><br><span class="hljs-comment"># 安装</span><br><span class="hljs-built_in">sudo</span> make install<br><br><span class="hljs-comment"># 打印版本以验证</span><br><span class="hljs-variable">$&#123;PREFIX&#125;</span>/bin/git --versioncd<br></code></pre></td></tr></table></figure><h3 id="6-修改代码验证"><a href="#6-修改代码验证" class="headerlink" title="6. 修改代码验证"></a>6. 修改代码验证</h3><p>这里我们在 <code>git.c</code>中的 cmd_main函数中加一句输出(git的程序入口)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cmd_main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is mygit building.\n&quot;</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译并在任意空目录使用mygit创建一个new repo<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109134323.png"><br>证明环境搭建成功。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路书计划-20240413</title>
    <link href="/2024/04/14/%E8%B7%AF%E4%B9%A6%E8%AE%A1%E5%88%92-20240413/"/>
    <url>/2024/04/14/%E8%B7%AF%E4%B9%A6%E8%AE%A1%E5%88%92-20240413/</url>
    
    <content type="html"><![CDATA[<h1 id="首先记录这美好的一天"><a href="#首先记录这美好的一天" class="headerlink" title="首先记录这美好的一天"></a>首先记录这美好的一天</h1><p>先放一下昨天晚上的规划<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133637.png"></p><p>今天蛮早就醒了，还是很期待今天会遇到什么的，虽然心里知道大概率也不会有什么太特别的事，但是谁知道呢哈哈哈，而且另外一方面感觉像是约定好了的一天，心里很充实。<br>吃过早饭后，骑上共享小电车到了最近的一个地铁站，做了几站地铁到了今天的第一站郫筒。<br>其实路过过很多次，一直没下来过，也挺好奇为什么叫郫筒的，所以还去特意查了一下，大概是说郫县有一个郫筒池，然后郫县的人会在这个池子旁边酿酒（用竹筒、蕉叶啥的），管这种酒叫郫筒酒，后来就有了这个地方。不过不重要，来这里还是想找一些市井的范围，找一找郫县人的松弛感。所以也没有特意的往想要往哪里走，只是定了一下中午要吃饭的地方。<br>然后就开始闲逛，逛的时候特地记了一下都走过了哪些街道，因为记得昨天靓靓说可以记录下来点亮一下去过的地方。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133702.png"><br>安民街算是出发的第一条街道，走着走着发现一个小公园，有叔叔阿姨带娃晒太阳，有年轻人出来遛狗，也有老人打牌、玩健身器材。还看到一个老奶奶在晒太阳睡着了，真的特别安详的感觉。随便照了一些东西，记录下这种松弛感，确确实实是我现在很需要的，感觉很治愈，也让我一直紧绷的心情放松了很多。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133712.png"><br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133724.png"><br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133734.png"><br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133741.png"><br>之后还进了一条什么王府商业街，其实没太感兴趣的，但是这条街可以上到二楼去，不知道为什么从小就喜欢往高处爬所以就过去了，在上面转了转，没看到什么太有意思的东西，不过这里放一张照片，不知道靓靓同学看到以后知不知道我想照什么哈哈哈哈。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133751.png"><br>之后在这边随便逛了逛，其实心里也没有太多预期，只是尝试想去融入到这种轻松的氛围里去，什么也不用想，什么也不用操心，完完全全的让自己的身体放空，心灵也放空。想象了一下自己也过着简单的生活，其实也蛮幸福的。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133800.png"><br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133809.png"><br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133816.png"><br>吃过午饭后去了下望从祠，其实没有特别喜欢哈哈哈哈，但是植物很多也很凉爽，很适合休息一下，所以也待了好一会，在这里也没有照什么，大部分时间都在一个长椅上闭目养生，呼吸久违的新鲜空气，有泥土的味道，参杂着一些花香，还有一丝丝铝的味道，但是不知道是哪里来的哈哈哈<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133823.png"><br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133829.png"><br>之后就打算去了下清水河艺术公园，本科一直在沙河，所以对清水河到底是一条什么河其实也没什么概念，所以还是挺想去看下的。哦对，今天我的主要交通工具就是下面这个东西，晃晃悠悠、慢慢吞吞的很符合我今天的心境。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133844.png"><br>下了有轨电车后出现了个小插曲，走错了路，但是在路上捡到了一块钱哈哈哈哈，觉得运气还挺不错的。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133852.png"><br>在这个公园里转了转，很多人搭帐篷、放风筝、烤肉、聊天、放歌等等等等，基本都是沿着清水河的河道，想到了之前靓靓说的亲水性的问题，亲水性还蛮好的。大概转了一圈后，突然有点想给靓靓打个电话，但感觉打电话好像又有点突兀，主要是很想知道她现在眼前是什么，所以发了微信，还蛮巧的哈哈哈哈。在草坪上又坐了一会，给子扬打了个电话，他这几天生病了，于是问候了一下。<br>之后其实有点疲惫了，就没有去第四个地方，但是突然想到离之前想去的一个吃饭的地方很近，正好逛到这会有些饿了，于是就直接骑电动车过去了。去了以后发现真的是苍蝇馆子中的苍蝇馆子哈哈哈哈，点菜的方式也挺有意思，点菜的窗口堆满了食材，点一道菜厨师就放对应的食材到小盆盆里，然后标记好是哪一桌，点了一个肝腰合炒和泡椒鸡杂，味道真的是很好。吃过之后就回学校啦。<br>路上决定要去看电影，和靓靓的场次其实还蛮同步的，像是一起去看的一样。这个片子其实之前听几个朋友推荐过，也一直蛮想看的。整个看下来真的是特别喜欢，特别特别喜欢。第一个原因是我感觉这部电影像是作者和自己的对话，我猜可能有很多情节都是和自身的经历有些关系，我觉得能用这种方式，把自我抽离出来去看曾经的事情才能真的和自己和解。其次是我很喜欢最后的情绪表达，整部电影只提过一次你想活出怎样的人生，而更多的再说你想要一个什么样的世界，其实世界是客观的也是主观的，而且终究对于每个人都是主观的，每个人的认知构成了每个人眼中的世界，也在这种认知的过程中去改造自己眼中的世界，找到自己想要的人生。真的很喜欢。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133928.png"><br>好了，最后就是去喝了点酒，感觉如此美好的一天不喝点总归是说不过去的。<br><img src="https://picbed-1300534156.cos.ap-chengdu.myqcloud.com/img/20241109133935.png"><br>另外我还要写一段话来阐述一下再写这些时的心境。我很高兴认识了靓靓，或者说了解了她，能如此有默契真的是我之前完全没有想到的。路书计划就只是随便聊聊就一拍即合了，真的觉的这种感觉很奇妙，我很少和别人这么深入的去表露我自己的很多想法，也很少觉得有人能理解我的心境（可能也是和我不怎么表露有关，并不是有多深奥hhh），我真的觉得是很幸运的，也真的很希望这种感觉可以持续下去，这种默契可以一直都存在，这种彼此感到满足的感觉不会间断。<br>以上，敬这美好的一天。</p><h1 id="一些给之后的tips"><a href="#一些给之后的tips" class="headerlink" title="一些给之后的tips"></a>一些给之后的tips</h1><ol><li>没有必要带相机其实，蛮沉的哈哈哈哈。</li><li>下次开始之前可以考虑一下这个过程中要听什么。</li><li>计划的粒度还是要更细一些。</li><li>保持水分充足。</li><li>前一天保证睡眠。</li></ol><h1 id="一些地标的记录"><a href="#一些地标的记录" class="headerlink" title="一些地标的记录"></a>一些地标的记录</h1><p>清水河艺术生态公园</p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-103.86-30.79" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-103.86-30.79',{center:[30.79,103.86],zoom:15,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.79','103.86']).addTo(mymap);marker.bindPopup("人很多，很适合过来露营！").openPopup();</script><p>郫筒</p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-103.89-30.80" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-103.89-30.80',{center:[30.80,103.89],zoom:15,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.80','103.89']).addTo(mymap);marker.bindPopup("还成吧，随便逛逛！").openPopup();</script><p>望从祠</p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-103.87-30.81" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-103.87-30.81',{center:[30.81,103.87],zoom:15,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.81','103.87']).addTo(mymap);marker.bindPopup("很凉快，空气很好！").openPopup();</script><p>南华大学</p><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-112.52-26.88" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-112.52-26.88',{center:[26.88,112.52],zoom:15,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['26.88','112.52']).addTo(mymap);marker.bindPopup("嘿嘿嘿").openPopup();</script>]]></content>
    
    
    <categories>
      
      <category>生活记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>photo</tag>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/03/hello-world/"/>
    <url>/2024/04/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Create-a-draft"><a href="#Create-a-draft" class="headerlink" title="Create a draft"></a>Create a draft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft &lt;title&gt;<br></code></pre></td></tr></table></figure><h3 id="Preview-draft"><a href="#Preview-draft" class="headerlink" title="Preview draft"></a>Preview draft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo S --draft<br></code></pre></td></tr></table></figure><h3 id="Release-draft"><a href="#Release-draft" class="headerlink" title="Release draft"></a>Release draft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo P &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
